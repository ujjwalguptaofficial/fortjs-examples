/*!
 * @license :fortjs - V2.5.4 - 28/11/2023
 * https://github.com/ujjwalguptaofficial/fortjs
 * Copyright (c) 2023 @Ujjwal Gupta; Licensed MIT
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ComponentOption: () => (/* reexport */ ComponentOption),
  Components: () => (/* reexport */ Components),
  Controller: () => (/* reexport */ Controller),
  CookieManager: () => (/* reexport */ CookieManager),
  DATA_TYPE: () => (/* reexport */ DATA_TYPE),
  DtoValidator: () => (/* reexport */ DtoValidator),
  ERROR_TYPE: () => (/* reexport */ ERROR_TYPE),
  ETAG_TYPE: () => (/* reexport */ ETAG_TYPE),
  ErrorHandler: () => (/* reexport */ ErrorHandler),
  FileManager: () => (/* reexport */ FileManager),
  Fort: () => (/* reexport */ Fort),
  Guard: () => (/* reexport */ Guard),
  HTTP_METHOD: () => (/* reexport */ HTTP_METHOD),
  HTTP_RESULT_TYPE: () => (/* reexport */ HTTP_RESULT_TYPE),
  HTTP_STATUS_CODE: () => (/* reexport */ HTTP_STATUS_CODE),
  HttpCookie: () => (/* reexport */ HttpCookie),
  HttpFile: () => (/* reexport */ HttpFile),
  JsonHelper: () => (/* reexport */ JsonHelper),
  LogHelper: () => (/* reexport */ LogHelper),
  Logger: () => (/* reexport */ Logger),
  MIME_TYPE: () => (/* reexport */ MIME_TYPE),
  MustacheViewEngine: () => (/* reexport */ MustacheViewEngine),
  ResultMapper: () => (/* reexport */ ResultMapper),
  RouteInfo: () => (/* reexport */ RouteInfo),
  Router: () => (/* reexport */ Router),
  Shield: () => (/* reexport */ Shield),
  ValidateBodyGuard: () => (/* reexport */ ValidateBodyGuard),
  ValidateParamGuard: () => (/* reexport */ ValidateParamGuard),
  ValidateQueryShield: () => (/* reexport */ ValidateQueryShield),
  ViewEngine: () => (/* reexport */ ViewEngine),
  Wall: () => (/* reexport */ Wall),
  WorkerInfo: () => (/* reexport */ WorkerInfo),
  XmlParser: () => (/* reexport */ XmlParser),
  asBody: () => (/* reexport */ asBody),
  asParam: () => (/* reexport */ asParam),
  asQuery: () => (/* reexport */ asQuery),
  assign: () => (/* reexport */ assign_assign),
  defaultWorker: () => (/* reexport */ defaultWorker),
  downloadResult: () => (/* reexport */ downloadResult),
  fileResult: () => (/* reexport */ fileResult),
  getClassName: () => (/* reexport */ getClassName),
  getDataType: () => (/* reexport */ getDataType),
  getMimeTypeFromExtension: () => (/* reexport */ getMimeTypeFromExtension),
  getMimeTypeFromFileType: () => (/* reexport */ getMimeTypeFromFileType),
  getResultBasedOnMiMe: () => (/* reexport */ getResultBasedOnMiMe),
  getViewFromFile: () => (/* reexport */ getViewFromFile),
  guards: () => (/* reexport */ guards),
  htmlResult: () => (/* reexport */ htmlResult),
  http: () => (/* reexport */ http),
  initController: () => (/* reexport */ initController),
  initGuard: () => (/* reexport */ initGuard),
  initShield: () => (/* reexport */ initShield),
  initWall: () => (/* reexport */ initWall),
  joinRoute: () => (/* reexport */ joinRoute),
  jsonResult: () => (/* reexport */ jsonResult),
  multiTypeResult: () => (/* reexport */ multiTypeResult),
  parseAndMatchRoute: () => (/* reexport */ parseAndMatchRoute),
  parseCookie: () => (/* reexport */ parseCookie),
  promise: () => (/* reexport */ promise),
  redirectResult: () => (/* reexport */ redirectResult),
  removeFirstSlash: () => (/* reexport */ removeFirstSlash),
  removeLastSlash: () => (/* reexport */ removeLastSlash),
  removeMethodAndNullFromObject: () => (/* reexport */ removeMethodAndNullFromObject),
  renderView: () => (/* reexport */ renderView),
  reverseLoop: () => (/* reexport */ reverseLoop),
  route: () => (/* reexport */ route),
  setResultMapper: () => (/* reexport */ setResultMapper),
  shields: () => (/* reexport */ shields),
  singleton: () => (/* reexport */ singleton),
  splitRoute: () => (/* reexport */ splitRoute),
  textResult: () => (/* reexport */ textResult),
  validate: () => (/* reexport */ validate),
  viewResult: () => (/* reexport */ viewResult),
  worker: () => (/* reexport */ worker)
});

;// CONCATENATED MODULE: ./src/enums/mime_type.ts
var MIME_TYPE;
(function (MIME_TYPE) {
    MIME_TYPE["Text"] = "text/plain";
    MIME_TYPE["Json"] = "application/json";
    MIME_TYPE["Html"] = "text/html";
    MIME_TYPE["FormUrlEncoded"] = "application/x-www-form-urlencoded";
    MIME_TYPE["Css"] = "text/css";
    MIME_TYPE["Csv"] = "text/csv";
    MIME_TYPE["Js"] = "application/javascript";
    MIME_TYPE["Bmp"] = "image/bmp";
    MIME_TYPE["Jpeg"] = "image/jpeg";
    MIME_TYPE["Gif"] = "image/gif";
    MIME_TYPE["Ico"] = "image/x-icon";
    MIME_TYPE["Png"] = "image/png";
    MIME_TYPE["Pdf"] = "application/pdf";
    MIME_TYPE["Svg"] = "image/svg+xml";
    MIME_TYPE["Rtf"] = "application/rtf";
    MIME_TYPE["Xml"] = "application/xml";
    MIME_TYPE["Xls"] = "application/vnd.ms-excel";
    MIME_TYPE["Xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    MIME_TYPE["Ttf"] = "font/ttf";
    MIME_TYPE["Woff"] = "font/woff";
    MIME_TYPE["Woff2"] = "font/woff2";
    MIME_TYPE["Eot"] = "application/vnd.ms-fontobject";
    MIME_TYPE["Otf"] = "font/otf";
    MIME_TYPE["Swf"] = "application/x-shockwave-flash";
    MIME_TYPE["Avi"] = "video/avi";
    MIME_TYPE["FormMultiPart"] = "multipart/form-data";
})(MIME_TYPE || (MIME_TYPE = {}));

;// CONCATENATED MODULE: ./src/enums/http_method.ts
var HTTP_METHOD;
(function (HTTP_METHOD) {
    HTTP_METHOD["Get"] = "GET";
    HTTP_METHOD["Post"] = "POST";
    HTTP_METHOD["Put"] = "PUT";
    HTTP_METHOD["Patch"] = "PATCH";
    HTTP_METHOD["Delete"] = "DELETE";
    HTTP_METHOD["Options"] = "OPTIONS";
    HTTP_METHOD["Head"] = "HEAD";
})(HTTP_METHOD || (HTTP_METHOD = {}));

;// CONCATENATED MODULE: ./src/enums/http_status_code.ts
var HTTP_STATUS_CODE;
(function (HTTP_STATUS_CODE) {
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["BadRequest"] = 400] = "BadRequest";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["Unauthorized"] = 401] = "Unauthorized";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["Forbidden"] = 403] = "Forbidden";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["NotFound"] = 404] = "NotFound";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["Ok"] = 200] = "Ok";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["Created"] = 201] = "Created";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["NoContent"] = 204] = "NoContent";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["Redirect"] = 302] = "Redirect";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["NotModified"] = 304] = "NotModified";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["NotAcceptable"] = 406] = "NotAcceptable";
    HTTP_STATUS_CODE[HTTP_STATUS_CODE["InternalServerError"] = 500] = "InternalServerError";
})(HTTP_STATUS_CODE || (HTTP_STATUS_CODE = {}));

;// CONCATENATED MODULE: ./src/enums/etag_type.ts
var ETAG_TYPE;
(function (ETAG_TYPE) {
    ETAG_TYPE["Strong"] = "strong";
    ETAG_TYPE["Weak"] = "weak";
})(ETAG_TYPE || (ETAG_TYPE = {}));

;// CONCATENATED MODULE: ./src/enums/error_type.ts
var ERROR_TYPE;
(function (ERROR_TYPE) {
    ERROR_TYPE["InvalidControllerName"] = "invalid_controller_name";
    ERROR_TYPE["InvalidContentType"] = "invalid_content_type";
    ERROR_TYPE["PortInUse"] = "port_in_use";
    ERROR_TYPE["UndefinedViewEngine"] = "undefined_view_engine";
})(ERROR_TYPE || (ERROR_TYPE = {}));

;// CONCATENATED MODULE: ./src/enums/data_type.ts
var DATA_TYPE;
(function (DATA_TYPE) {
    DATA_TYPE["String"] = "string";
    DATA_TYPE["Number"] = "number";
    DATA_TYPE["Array"] = "array";
    DATA_TYPE["Object"] = "object";
    DATA_TYPE["Function"] = "function";
})(DATA_TYPE || (DATA_TYPE = {}));

;// CONCATENATED MODULE: ./src/enums/http_result_type.ts
var HTTP_RESULT_TYPE;
(function (HTTP_RESULT_TYPE) {
    HTTP_RESULT_TYPE[HTTP_RESULT_TYPE["Default"] = 0] = "Default";
    HTTP_RESULT_TYPE[HTTP_RESULT_TYPE["File"] = 1] = "File";
    HTTP_RESULT_TYPE[HTTP_RESULT_TYPE["Redirect"] = 2] = "Redirect";
    HTTP_RESULT_TYPE[HTTP_RESULT_TYPE["FormattedResult"] = 3] = "FormattedResult";
})(HTTP_RESULT_TYPE || (HTTP_RESULT_TYPE = {}));

;// CONCATENATED MODULE: ./src/enums/index.ts








;// CONCATENATED MODULE: ./src/helpers/json_result.ts


const jsonResult = (value, statusCode) => {
    return {
        contentType: MIME_TYPE.Json,
        responseData: value,
        statusCode: statusCode || HTTP_STATUS_CODE.Ok,
        type: HTTP_RESULT_TYPE.Default
    };
};

;// CONCATENATED MODULE: ./src/helpers/text_result.ts


const textResult = (text, statusCode) => {
    return {
        contentType: MIME_TYPE.Text,
        responseData: text,
        statusCode: statusCode || HTTP_STATUS_CODE.Ok,
        type: HTTP_RESULT_TYPE.Default
    };
};

;// CONCATENATED MODULE: ./src/helpers/html_result.ts


const htmlResult = (html, statusCode) => {
    return {
        contentType: MIME_TYPE.Html,
        responseData: html,
        statusCode: statusCode || HTTP_STATUS_CODE.Ok,
        type: HTTP_RESULT_TYPE.Default
    };
};

;// CONCATENATED MODULE: ./src/abstracts/component.ts

class Component {
    get request() {
        return this.componentProp_.request;
    }
    get response() {
        return this.componentProp_.response;
    }
    get query() {
        return this.componentProp_.query;
    }
    get session() {
        return this.componentProp_.session;
    }
    get cookie() {
        return this.componentProp_.cookie;
    }
    get data() {
        return this.componentProp_.data;
    }
    get logger() {
        return FORT_GLOBAL.logger;
    }
    get option() {
        return FORT_GLOBAL.componentOption;
    }
}

;// CONCATENATED MODULE: ./src/abstracts/controller.ts


class Controller extends Component {
    get body() {
        return this['componentProp_'].body;
    }
    get param() {
        return this['componentProp_'].param;
    }
    get file() {
        return this['componentProp_'].file;
    }
    // eslint-disable-next-line
    constructor(...args) {
        super();
    }
    initialize(data) {
        initController(this, data);
    }
}

;// CONCATENATED MODULE: ./src/abstracts/shield.ts



class Shield extends Component {
    get workerName() {
        return this['componentProp_'].workerName;
    }
    get logger() {
        return FORT_GLOBAL.logger;
    }
    get option() {
        return FORT_GLOBAL.componentOption;
    }
    // eslint-disable-next-line
    constructor(...args) {
        super();
    }
    initialize(data) {
        return initShield(this, data);
    }
}

;// CONCATENATED MODULE: ./src/abstracts/guard.ts



class Guard extends Component {
    get body() {
        return this['componentProp_'].body;
    }
    get param() {
        return this['componentProp_'].param;
    }
    get file() {
        return this['componentProp_'].file;
    }
    get workerName() {
        return this['componentProp_'].workerName;
    }
    get logger() {
        return FORT_GLOBAL.logger;
    }
    get option() {
        return FORT_GLOBAL.componentOption;
    }
    // eslint-disable-next-line
    constructor(...args) {
        super();
    }
    initialize(data) {
        return initGuard(this, data);
    }
}

;// CONCATENATED MODULE: ./src/abstracts/view_engine.ts
class ViewEngine {
}

;// CONCATENATED MODULE: ./src/abstracts/wall.ts


class Wall extends Component {
    // eslint-disable-next-line
    onOutgoing(finalResult, ...args) {
    }
    // eslint-disable-next-line
    constructor(...args) {
        super();
    }
    initialize(data) {
        return initWall(this, data);
    }
}

;// CONCATENATED MODULE: ./src/abstracts/xml_parser.ts
class XmlParser {
}

;// CONCATENATED MODULE: ./src/abstracts/result_mapper.ts
class ResultMapper {
}

;// CONCATENATED MODULE: ./src/abstracts/component_option.ts
class ComponentOption {
    toModel(expectedClass, from) {
        const result = new expectedClass();
        for (const prop in result) {
            result[prop] = from[prop];
        }
        return result;
    }
    extractHash(expectedHash, from) {
        for (const prop in expectedHash) {
            expectedHash[prop] = from[prop];
        }
        return expectedHash;
    }
    isNull(value) {
        return value == null;
    }
    isNullOrEmpty(value) {
        return value == null || value.length === 0;
    }
    isEmpty(value) {
        return value.length === 0;
    }
}

;// CONCATENATED MODULE: ./src/abstracts/index.ts









;// CONCATENATED MODULE: external "mustache"
const external_mustache_namespaceObject = require("mustache");
;// CONCATENATED MODULE: ./src/extra/mustache_view_engine.ts


class MustacheViewEngine {
    render(value) {
        return getViewFromFile({
            fileLocation: value.view
        }).then(viewData => {
            return external_mustache_namespaceObject.render(viewData, value.model);
        });
    }
}

;// CONCATENATED MODULE: external "class-validator"
const external_class_validator_namespaceObject = require("class-validator");
;// CONCATENATED MODULE: ./src/extra/dto_validator.ts



const defaultErrorResultMapper = (validationResult) => {
    return jsonResult({
        error: {
            message: validationResult,
            type: "ValidationError",
        }
    }, HTTP_STATUS_CODE.BadRequest);
};
class DtoValidator {
    constructor(validatorOption = null, errorResultMapper = defaultErrorResultMapper) {
        // const defaultValidatorOption = {
        //     // whitelist: true,
        //     // forbidNonWhitelisted: true,
        //     // forbidUnknownValues: false
        // } as ValidatorOptions;
        this.validatorOption = validatorOption;
        // Object.assign(defaultValidatorOption, validatorOption);
        this.validatorOption = validatorOption;
        this.getErrorResult = errorResultMapper;
    }
    async validate(dtoInstance) {
        const errors = await (0,external_class_validator_namespaceObject.validate)(dtoInstance, this.validatorOption);
        if (errors.length > 0) {
            const error = errors[0];
            const constraint = Object.keys(error.constraints)[0];
            const errMessage = error.constraints[constraint];
            if (error) {
                return errMessage;
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/extra/index.ts



;// CONCATENATED MODULE: ./src/constants/index.ts
const CONTENT_TYPE = "Content-Type";
const APP_NAME = "fort";
const COOKIE = "Cookie";
const SET_COOKIE = 'Set-Cookie';
const CURRENT_PATH = process.cwd();
const CONTENT_LENGTH = "Content-Length";
const CONSTRUCTOR = "const_constructor";


;// CONCATENATED MODULE: ./src/utils/is_null_or_empty.ts
const isNullOrEmpty = (value) => {
    return value == null || value.length === 0;
};

;// CONCATENATED MODULE: ./src/utils/is_null.ts
const isNull = (value) => {
    return value == null;
};

;// CONCATENATED MODULE: ./src/utils/is_array.ts
const isArray = (value) => {
    return Array.isArray(value);
};

;// CONCATENATED MODULE: ./src/utils/promise_resolve.ts
const promiseResolve = (value) => {
    return Promise.resolve(value);
};

;// CONCATENATED MODULE: ./src/utils/compare_string.ts
const compareString = (str1, str2) => {
    return new RegExp('^' + str1 + '$', 'i').test(str2);
};

;// CONCATENATED MODULE: external "uniqid"
const external_uniqid_namespaceObject = require("uniqid");
;// CONCATENATED MODULE: ./src/utils/session_manager.ts


class SessionManager {
    constructor(cookie, sessionStore) {
        this.sessionId = cookie.cookieCollection[FORT_GLOBAL.appSessionIdentifier];
        this.sessionStore = new sessionStore(this.sessionId);
        this.cookie = cookie;
    }
    createSession(sessionId) {
        const now = new Date();
        this.sessionId = sessionId != null ? sessionId : external_uniqid_namespaceObject();
        this.cookie.addCookie({
            name: FORT_GLOBAL.appSessionIdentifier,
            value: this.sessionId,
            httpOnly: true,
            path: "/",
            expires: new Date(now.setMinutes(now.getMinutes() + FORT_GLOBAL.sessionTimeOut)),
            maxAge: FORT_GLOBAL.sessionTimeOut * 60
        });
    }
    destroySession() {
        const cookie = this.cookie.getCookie(FORT_GLOBAL.appSessionIdentifier);
        cookie.httpOnly = true;
        cookie.path = "/";
        this.cookie.removeCookie(cookie);
    }
    get(key) {
        return this.sessionStore.get(key);
    }
    isExist(key) {
        return this.sessionStore.isExist(key);
    }
    getAll() {
        return this.sessionStore.getAll();
    }
    async set(key, val) {
        const savedValue = await this.sessionStore.isAnyExist();
        if (savedValue === false) {
            this.createSession();
            this.sessionStore.sessionId = this.sessionId;
        }
        await this.sessionStore.set(key, val);
    }
    setMany(values) {
        return this.sessionStore.setMany(values);
    }
    remove(key) {
        return this.sessionStore.remove(key);
    }
    async clear() {
        // remove session values
        await this.sessionStore.clear();
        // expire cookie in browser
        this.destroySession();
    }
}

;// CONCATENATED MODULE: ./src/utils/index.ts







;// CONCATENATED MODULE: ./src/providers/cookie_wall.ts





class CookieEvaluatorWall extends Wall {
    parseCookieFromRequest() {
        const componentProps = this['componentProp_'];
        if (FORT_GLOBAL.shouldParseCookie === false) {
            componentProps.cookie = new CookieManager({});
            return;
        }
        const request = this.request;
        const rawCookie = (request.headers[COOKIE] || request.headers["cookie"]);
        const parsedCookies = parseCookie(rawCookie);
        const cookie = new CookieManager(parsedCookies);
        const session = new SessionManager(cookie, FORT_GLOBAL.sessionStore);
        componentProps.session = session;
        componentProps.cookie = cookie;
    }
    async onIncoming() {
        this.parseCookieFromRequest();
    }
}

;// CONCATENATED MODULE: external "content-type"
const external_content_type_namespaceObject = require("content-type");
;// CONCATENATED MODULE: external "querystring"
const external_querystring_namespaceObject = require("querystring");
;// CONCATENATED MODULE: external "multiparty"
const external_multiparty_namespaceObject = require("multiparty");
;// CONCATENATED MODULE: ./src/providers/post_data_evaluator_guard.ts









class PostDataEvaluatorGuard extends Guard {
    async check() {
        try {
            const postResult = await this.handlePostData();
            const componentProps = this['componentProp_'];
            componentProps.file = postResult[0];
            componentProps.body = postResult[1];
        }
        catch (error) {
            return textResult(error.message || `Invalid body data. Check your data format.`, HTTP_STATUS_CODE.BadRequest);
        }
    }
    async handlePostData() {
        if (this.request.method === HTTP_METHOD.Get) {
            return [new FileManager({}), {}];
        }
        return this.parsePostData();
    }
    getPostRawData_() {
        const body = [];
        return promise((res, rej) => {
            this.request.on('data', (chunk) => {
                body.push(chunk);
            }).on('end', () => {
                const bodyBuffer = Buffer.concat(body);
                res(bodyBuffer.toString());
            }).on("error", function (err) {
                rej(err);
            });
        });
    }
    parseMultiPartData_() {
        return promise((res, rej) => {
            new external_multiparty_namespaceObject.Form().parse(this.request, (err, fields, files) => {
                if (err) {
                    rej(err);
                }
                else {
                    const result = {
                        field: {},
                        file: {}
                    };
                    for (const field in fields) {
                        result.field[field] = fields[field].length === 1 ? fields[field][0] : fields[field];
                    }
                    for (const file in files) {
                        result.file[file] = files[file].length === 1 ? files[file][0] : files[file];
                    }
                    res(result);
                }
            });
        });
    }
    async parsePostData() {
        let contentType = this.request.headers[CONTENT_TYPE] || this.request.headers["content-type"];
        if (contentType != null) {
            contentType = external_content_type_namespaceObject.parse(contentType).type;
        }
        if (contentType === MIME_TYPE.FormMultiPart) {
            const multipartyResult = await this.parseMultiPartData_();
            return [new FileManager(multipartyResult.file), multipartyResult.field];
        }
        else {
            let postData;
            const bodyDataAsString = await this.getPostRawData_();
            switch (contentType) {
                case MIME_TYPE.Json:
                    postData = JsonHelper.parse(bodyDataAsString);
                    break;
                case MIME_TYPE.Text:
                case MIME_TYPE.Html:
                    postData = bodyDataAsString;
                    break;
                case MIME_TYPE.FormUrlEncoded:
                    postData = external_querystring_namespaceObject.parse(bodyDataAsString);
                    break;
                case MIME_TYPE.Xml:
                    postData = new this['componentProp_'].global.xmlParser().parse(bodyDataAsString);
                    break;
                default:
                    postData = {};
            }
            return [new FileManager({}), postData];
        }
    }
}

;// CONCATENATED MODULE: ./src/providers/memory_session_store.ts
const sessionValues = new Map();
class MemorySessionStore {
    constructor(sessionId) {
        this.sessionId = sessionId;
    }
    getSessionValue_() {
        return sessionValues.get(this.sessionId);
    }
    async isAnyExist() {
        return this.getSessionValue_() != null;
    }
    async get(key) {
        const savedValue = this.getSessionValue_();
        return savedValue != null ? savedValue[key] : null;
    }
    async getAll() {
        const savedValue = this.getSessionValue_();
        return savedValue || {};
    }
    async isExist(key) {
        const savedValue = this.getSessionValue_();
        return savedValue == null ? false : savedValue[key] != null;
    }
    async clear() {
        // remove session values
        sessionValues.delete(this.sessionId);
    }
    async set(key, val) {
        const savedValue = this.getSessionValue_();
        if (savedValue == null) {
            sessionValues.set(this.sessionId, {
                [key]: val
            });
        }
        else {
            savedValue[key] = val;
        }
    }
    setMany(values) {
        return Promise.all(Object.keys(values).map((key) => {
            return this.set(key, values[key]);
        }));
    }
    async remove(key) {
        const savedValue = this.getSessionValue_();
        if (savedValue != null) {
            savedValue[key] = null;
        }
    }
}

;// CONCATENATED MODULE: ./src/providers/generic_xml_parser.ts
class BlankXmlParser {
    parse() {
        // tslint:disable-next-line
        throw {
            message: "no xml parser configured"
        };
    }
}

;// CONCATENATED MODULE: ./src/providers/index.ts





;// CONCATENATED MODULE: ./src/handlers/route_handler.ts



const routerCollection = new Map();
const pushRouterIntoCollection = (route) => {
    const routeObj = new RouteInfo(route);
    routerCollection.set(route.controllerName, routeObj);
};
const getWorkerPattern = (parentRoute, pattern) => {
    const routeWithParent = (isNull(parentRoute.path) || parentRoute.path === "/*") ? pattern : `${parentRoute.path}${pattern}`;
    return routeWithParent;
};
const routeCache = new Map();
class RouteHandler {
    static get routerCollection() {
        return routerCollection;
    }
    static get routesAsArray() {
        return Array.from(routerCollection.keys()).map(workerName => {
            return routerCollection.get(workerName);
        });
    }
    static findControllerFromPath(urlParts) {
        for (const controller of routerCollection.values()) {
            let isMatched;
            const patternSplit = controller.pathSplitted;
            patternSplit.every((patternPart, i) => {
                isMatched = compareString(urlParts[i], patternPart);
                return isMatched;
            });
            if (isMatched === true) {
                return controller;
            }
        }
    }
    static getControllerFromName(name) {
        return routerCollection.get(name);
    }
    static get defaultRoute() {
        return routerCollection.get(RouteHandler.defaultRouteControllerName);
    }
    static addToRouterCollection(value) {
        const route = routerCollection.get(value.controller.name);
        if (route == null) {
            pushRouterIntoCollection({
                workers: new Map(),
                controller: value.controller,
                controllerName: value.controller.name,
                path: value.path,
                shields: [],
                values: []
            });
        }
        else {
            route.controller = value.controller;
            route.path = value.path;
            // change pattern value since we have controller name now.
            route.workers.forEach(actionInfo => {
                actionInfo.pattern = getWorkerPattern(value, actionInfo.pattern);
            });
        }
    }
    static addShields(shields, className) {
        const route = routerCollection.get(className);
        if (route == null) {
            pushRouterIntoCollection({
                workers: new Map(),
                controller: null,
                controllerName: className,
                shields: shields,
                path: null,
                values: []
            });
        }
        else {
            route.shields = route.shields ? [...route.shields, ...shields] : shields;
        }
    }
    static addWorker(newWorker, className) {
        const workerName = newWorker.workerName;
        const route = routerCollection.get(className);
        if (route == null) {
            pushRouterIntoCollection({
                workers: new Map([
                    [workerName, new WorkerInfo(newWorker)]
                ]),
                controller: null,
                controllerName: className,
                shields: [],
                path: null,
                values: []
            });
        }
        else {
            const savedAction = route.workers.get(workerName);
            if (savedAction == null) {
                newWorker.pattern = getWorkerPattern(route, newWorker.pattern);
                route.workers.set(workerName, new WorkerInfo(newWorker));
            }
            else {
                savedAction.methodsAllowed = newWorker.methodsAllowed;
                savedAction.pattern = getWorkerPattern(route, savedAction.pattern);
                // route.path == null ? savedAction.pattern : `/${route.path}${savedAction.pattern}`;
            }
        }
    }
    static addGuards(guards, className, workerName) {
        const route = routerCollection.get(className);
        const pattern = workerName.toLowerCase();
        if (route == null) {
            pushRouterIntoCollection({
                workers: new Map([
                    [workerName, new WorkerInfo({
                            workerName: workerName,
                            guards: guards,
                            methodsAllowed: null,
                            pattern: pattern,
                            values: []
                        })]
                ]),
                controller: null,
                controllerName: className,
                shields: [],
                path: null,
                values: []
            });
        }
        else {
            const savedAction = route.workers.get(workerName);
            if (savedAction == null) {
                route.workers.set(workerName, new WorkerInfo({
                    workerName: workerName,
                    guards: guards,
                    methodsAllowed: null,
                    pattern: pattern,
                    values: []
                }));
            }
            else {
                savedAction.guards = savedAction.guards ? [...savedAction.guards, ...guards]
                    : guards;
            }
        }
    }
    static addPattern(pattern, className, workerName) {
        const route = routerCollection.get(className);
        if (route == null) {
            pushRouterIntoCollection({
                workers: new Map([
                    [workerName, new WorkerInfo({
                            workerName: workerName,
                            guards: [],
                            methodsAllowed: null,
                            pattern: pattern,
                            values: []
                        })]
                ]),
                controller: null,
                controllerName: className,
                shields: [],
                path: null,
                values: []
            });
        }
        else {
            const savedAction = route.workers.get(workerName);
            const workerRouteWithController = getWorkerPattern(route, pattern);
            if (savedAction == null) {
                route.workers.set(workerName, new WorkerInfo({
                    workerName: workerName,
                    guards: [],
                    methodsAllowed: null,
                    pattern: workerRouteWithController,
                    values: []
                }));
            }
            else {
                savedAction.pattern = workerRouteWithController;
            }
        }
    }
    static addExpected(type, className, workerName, expectedValue) {
        for (const prop in expectedValue) {
            const propValue = expectedValue[prop];
            expectedValue[prop] = getDataType(propValue);
        }
        const pattern = workerName.toLowerCase();
        const router = routerCollection.get(className);
        const worker = new WorkerInfo({
            workerName: workerName,
            guards: [],
            methodsAllowed: null,
            pattern: pattern,
            values: []
        });
        switch (type) {
            case "body":
                worker.expectedBody = expectedValue;
                break;
            case "query":
                worker.expectedQuery = expectedValue;
                break;
            case "param":
                worker.expectedParam = expectedValue;
                break;
        }
        if (router == null) {
            pushRouterIntoCollection({
                workers: new Map([
                    [workerName, worker]
                ]),
                controller: null,
                controllerName: className,
                shields: [],
                path: null,
                values: []
            });
        }
        else {
            const savedAction = router.workers.get(workerName);
            if (savedAction == null) {
                router.workers.set(workerName, worker);
            }
            else {
                savedAction.expectedQuery = worker.expectedQuery;
                savedAction.expectedBody = worker.expectedBody;
                savedAction.expectedParam = worker.expectedParam;
            }
        }
    }
    static getExpectedQuery(controllerName, workerName) {
        return routerCollection.get(controllerName).workers.get(workerName).expectedQuery;
    }
    static getExpectedBody(controllerName, workerName) {
        return routerCollection.get(controllerName).workers.get(workerName).expectedBody;
    }
    static getExpectedParam(controllerName, workerName) {
        return routerCollection.get(controllerName).workers.get(workerName).expectedParam;
    }
    static addRouteToCache(url, route) {
        routeCache.set(url, route);
    }
    static getRouteFromCache(url) {
        return routeCache.get(url);
    }
}

;// CONCATENATED MODULE: external "url"
const external_url_namespaceObject = require("url");
;// CONCATENATED MODULE: ./src/handlers/injector_handler.ts

// this stores information of injector values that are available per class & worker
// const injectorStoreInfos: InjectorStoreInfo[] = [];
const injectorStoreInfos = new Map();
// this stores injector values
const injectorValues = [];
// this stores the singletons name & their respective index in injector values
const singletons = new Map();
class InjectorHandler {
    static addWorkerValue(className, methodName, paramIndex, paramValue, shouldFindIndex = true) {
        if (shouldFindIndex === true) {
            const paramValueIndex = injectorValues.indexOf(paramValue);
            if (paramValueIndex < 0) {
                paramValue = injectorValues.push(paramValue) - 1;
            }
            else {
                paramValue = paramValueIndex;
            }
        }
        const savedValue = injectorStoreInfos.get(className);
        if (savedValue == null) {
            const methods = [];
            methods[paramIndex] = paramValue;
            const value = new Map();
            value.set(methodName, methods);
            injectorStoreInfos.set(className, value);
        }
        else {
            let savedMethod = savedValue.get(methodName);
            if (savedMethod == null) {
                savedMethod = [];
                savedValue.set(methodName, savedMethod);
            }
            savedMethod[paramIndex] = paramValue;
        }
        return paramValue;
    }
    static getConstructorValues(className) {
        return this.getMethodValues(className, CONSTRUCTOR, null);
    }
    static getMethodValues(className, methodName, component) {
        const savedValue = injectorStoreInfos.get(className);
        if (savedValue != null) {
            const methodArgs = savedValue.get(methodName);
            if (methodArgs != null) {
                return methodArgs.map(injectorValueIndex => {
                    const value = injectorValues[injectorValueIndex];
                    switch (value['__fortReqType__']) {
                        case "body":
                        case "query":
                        case "param":
                            return value.inject(component);
                    }
                    return value;
                });
            }
        }
        return [];
    }
    static addSingleton(className, methodName, paramIndex, paramValue) {
        const singletonClassName = paramValue.name;
        if (singletonClassName) {
            const singletonValueStored = singletons.get(singletonClassName);
            if (singletonValueStored == null) {
                singletons.set(singletonClassName, InjectorHandler.addWorkerValue(className, methodName, paramIndex, new paramValue()));
            }
            else {
                InjectorHandler.addWorkerValue(className, methodName, paramIndex, singletonValueStored, false);
            }
        }
    }
}

;// CONCATENATED MODULE: external "path"
const external_path_namespaceObject = require("path");
;// CONCATENATED MODULE: external "negotiator"
const external_negotiator_namespaceObject = require("negotiator");
;// CONCATENATED MODULE: ./src/handlers/request_handler_helper.ts





class RequestHandlerHelper {
    get request() {
        return this.componentProps.request;
    }
    get response() {
        return this.componentProps.response;
    }
    getContentTypeFromNegotiation(type) {
        const negotiator = new external_negotiator_namespaceObject(this.request);
        let availableTypes = this.getAvailableTypes_(type);
        if (availableTypes == null) {
            availableTypes = [type];
        }
        return negotiator.mediaType(availableTypes);
    }
    getContentTypeFromNegotiationHavingMultipleTypes(types) {
        const negotiator = new external_negotiator_namespaceObject(this.request);
        return negotiator.mediaType(types);
    }
    getAvailableTypes_(type) {
        switch (type) {
            case MIME_TYPE.Json:
            case MIME_TYPE.Xml:
                return [MIME_TYPE.Json, MIME_TYPE.Xml];
            case MIME_TYPE.Html:
            case MIME_TYPE.Css:
            case MIME_TYPE.Csv:
            case MIME_TYPE.Js:
            case MIME_TYPE.Rtf:
            case MIME_TYPE.Text:
                return [MIME_TYPE.Text, MIME_TYPE.Html, MIME_TYPE.Js,
                    MIME_TYPE.Css, MIME_TYPE.Rtf, MIME_TYPE.Csv];
        }
        return null;
    }
    onBadRequest(error) {
        return new FORT_GLOBAL.errorHandler().onBadRequest(error).then(data => {
            return this.onResultFromError_(data);
        });
    }
    onForbiddenRequest() {
        return new FORT_GLOBAL.errorHandler().onForbiddenRequest().then(data => {
            return this.onResultFromError_(data);
        });
    }
    onNotAcceptableRequest() {
        return new FORT_GLOBAL.errorHandler().onNotAcceptableRequest().then(data => {
            return this.onResultFromError_(data);
        });
    }
    onNotFound() {
        return new FORT_GLOBAL.errorHandler().onNotFound(this.request.url).then(data => {
            return this.onResultFromError_(data);
        });
    }
    onMethodNotAllowed(allowedMethods) {
        return new FORT_GLOBAL.errorHandler().onMethodNotAllowed().then(data => {
            this.response.setHeader("Allow", allowedMethods.join(","));
            return this.onResultFromError_(data);
        });
    }
    // it won't execute wallOutgoing as if there is some issue in wallOutgoing
    // then it would become an infinite loop
    // treat it as someone comes to your fort & they start doing things 
    // which was not supposed to be done
    // then you don't follow regular rules but just throw them from anywhere
    onErrorOccured(error) {
        if (typeof error === 'string') {
            error = {
                message: error
            };
        }
        return new FORT_GLOBAL.errorHandler().onServerError(error).then(data => {
            this.controllerResult = data;
            return this.returnResultFromError_();
        }).catch(ex => {
            const response = {
                message: ex.message,
                stack: ex.stack,
                type: ex.type
            };
            this.controllerResult = JSON.stringify(response);
            return this.returnResultFromError_();
        });
    }
    onRequestOptions(allowedMethods) {
        this.response.setHeader("Allow", allowedMethods.join(","));
        return this.onResultFromError_(textResult(""));
    }
    onResultFromError_(result) {
        this.controllerResult = result;
        this.returnResultFromError_();
    }
    setCookie() {
        if (FORT_GLOBAL.shouldParseCookie === false)
            return;
        (this.componentProps.cookie['responseCookie_']).forEach(value => {
            this.response.setHeader(SET_COOKIE, value);
        });
    }
    returnResultFromError_() {
        const result = this.controllerResult;
        this.setCookie();
        switch (result.type) {
            case HTTP_RESULT_TYPE.Default:
                {
                    const contentType = result.contentType || MIME_TYPE.Text;
                    const negotiateMimeType = this.getContentTypeFromNegotiation(contentType);
                    this.endResponse_(negotiateMimeType != null ? negotiateMimeType : contentType);
                }
                break;
            case HTTP_RESULT_TYPE.FormattedResult:
                return this.handleFormatResult_();
        }
    }
    handleFormatResult_(shouldSendFirstMatch = false) {
        const controllerResult = this.controllerResult;
        const responseData = controllerResult.responseData;
        const negotiateMimeType = this.getContentTypeFromNegotiationHavingMultipleTypes(Object.keys(responseData));
        let key = Object.keys(responseData).find(qry => qry === negotiateMimeType);
        if (key != null) {
            controllerResult.responseData = responseData[key]();
            this.endResponse_(negotiateMimeType);
        }
        else if (shouldSendFirstMatch === true) {
            key = Object.keys(responseData)[0];
            controllerResult.responseData = responseData[key]();
            this.endResponse_(negotiateMimeType);
        }
        else {
            return this.onNotAcceptableRequest();
        }
    }
    endResponse_(negotiateMimeType) {
        const data = getResultBasedOnMiMe(negotiateMimeType, (this.controllerResult).responseData, (type) => {
            negotiateMimeType = type;
        });
        if (this.response.headersSent) {
            console.trace("Request is finished, but triggered again");
            return;
        }
        this.response.writeHead(this.controllerResult.statusCode || HTTP_STATUS_CODE.Ok, { [CONTENT_TYPE]: negotiateMimeType });
        this.response.end(data);
    }
}

;// CONCATENATED MODULE: external "fs"
const external_fs_namespaceObject = require("fs");
;// CONCATENATED MODULE: external "etag"
const external_etag_namespaceObject = require("etag");
;// CONCATENATED MODULE: external "fresh"
const external_fresh_namespaceObject = require("fresh");
;// CONCATENATED MODULE: ./src/handlers/file_handler.ts










class FileHandler extends RequestHandlerHelper {
    getFileInfoFromUrl_(urlPath) {
        const splittedValue = urlPath.split("/");
        const fileInfo = {
            file: ""
        };
        if (splittedValue.length > 2 || !isNullOrEmpty(external_path_namespaceObject.parse(urlPath).ext)) {
            fileInfo.folder = splittedValue[1];
            fileInfo.file = splittedValue.splice(2).join("/");
            return fileInfo;
        }
        fileInfo.folder = splittedValue[1];
        return fileInfo;
    }
    getFileStats_(filePath) {
        return promise((res, rej) => {
            // eslint-disable-next-line
            external_fs_namespaceObject.lstat(filePath, (err, status) => {
                if (err) {
                    if (err.code === 'ENOENT') {
                        res(null);
                    }
                    else {
                        rej(err);
                    }
                }
                else {
                    res(status);
                }
            });
        });
    }
    handleFileRequestFromAbsolutePath(absolutePath, fileType) {
        return this.getFileStats_(absolutePath).then(fileInfo => {
            if (fileInfo != null) {
                if (fileInfo.isDirectory() === true) {
                    return this.handleFileRequestForFolderPath_(absolutePath);
                }
                else {
                    return this.sendFile_(absolutePath, fileType, fileInfo);
                }
            }
            else {
                return this.onNotFound();
            }
        });
    }
    checkForFolderAllowAndReturnPath_(urlPath) {
        const fileInfo = this.getFileInfoFromUrl_(urlPath);
        const getAbsPath = function () {
            const folder = FORT_GLOBAL.folders.find(qry => qry.alias === fileInfo.folder);
            if (folder != null) {
                return external_path_namespaceObject.join(folder.path, fileInfo.file);
            }
            return null;
        };
        let absPath = getAbsPath();
        if (absPath == null) {
            fileInfo.folder = "/";
            fileInfo.file = urlPath;
            absPath = getAbsPath();
        }
        return absPath;
    }
    handleFileRequest(urlPath) {
        const extension = external_path_namespaceObject.parse(urlPath).ext;
        const absFilePath = this.checkForFolderAllowAndReturnPath_(urlPath);
        if (absFilePath != null) {
            return this.handleFileRequestFromAbsolutePath(absFilePath, extension);
        }
        else {
            return this.onNotFound();
        }
    }
    /**
     * process folders handling asuuming path is folder.
     * Please check whether the file is folder before calling this function
     *
     * @private
     * @param {string} filePath
     * @param {Fs.Stats} fileInfo
     * @returns
     * @memberof FileHandler
     */
    handleFileRequestForFolderPath_(absolutePath) {
        absolutePath = external_path_namespaceObject.join(absolutePath, "index.html");
        return this.getFileStats_(absolutePath).then(fileInfo => {
            return fileInfo != null ?
                this.sendFile_(absolutePath, MIME_TYPE.Html, fileInfo) :
                this.onNotFound();
        });
    }
    isClientHasFreshFile(lastModified, etagValue) {
        return external_fresh_namespaceObject(this.request.headers, {
            'etag': etagValue,
            'last-modified': lastModified
        });
    }
    sendFileAsResponse(filePath, mimeType) {
        this.response.writeHead(HTTP_STATUS_CODE.Ok, {
            [CONTENT_TYPE]: mimeType
        });
        const readStream = external_fs_namespaceObject.createReadStream(filePath);
        // Handle non-existent file
        readStream.on('error', this.onErrorOccured.bind(this));
        readStream.on('open', () => {
            readStream.pipe(this.response);
        });
    }
    sendFile_(filePath, fileType, fileInfo) {
        const lastModified = fileInfo.mtime.toUTCString();
        const eTagValue = external_etag_namespaceObject(fileInfo, {
            weak: FORT_GLOBAL.eTag.type === ETAG_TYPE.Weak
        });
        const response = this.response;
        if (this.isClientHasFreshFile(lastModified, eTagValue)) { // client has fresh file
            response.statusCode = HTTP_STATUS_CODE.NotModified;
            response.end();
        }
        else {
            response.setHeader('Etag', eTagValue);
            response.setHeader('Last-Modified', lastModified);
            this.sendFileAsResponse(filePath, getMimeTypeFromFileType(fileType));
        }
    }
}

;// CONCATENATED MODULE: ./src/handlers/controller_result_handler.ts





class ControllerResultHandler extends FileHandler {
    handleRedirectResult_() {
        this.response.writeHead(this.controllerResult.statusCode || HTTP_STATUS_CODE.Ok, { 'Location': this.controllerResult.responseData });
        this.response.end();
        return promiseResolve(null);
    }
    handleFileResult_() {
        const result = this.controllerResult;
        const fileResult = result.responseData;
        const parsedPath = external_path_namespaceObject.parse(fileResult.filePath);
        if (fileResult.shouldDownload === true) {
            const fileName = fileResult.alias == null ? parsedPath.name : fileResult.alias;
            this.response.setHeader("content-disposition", `attachment;filename=${fileName}${parsedPath.ext}`);
        }
        return this.handleFileRequestFromAbsolutePath(fileResult.filePath, parsedPath.ext);
    }
    onTerminationFromWall(result) {
        this.controllerResult = result;
        return this.handleFinalResult_();
    }
    handleFinalResult_() {
        const result = this.controllerResult;
        this.setCookie();
        switch (result.type) {
            case HTTP_RESULT_TYPE.Default:
                {
                    const contentType = result.contentType || MIME_TYPE.Text;
                    const negotiateMimeType = this.getContentTypeFromNegotiation(contentType);
                    if (negotiateMimeType != null) {
                        this.endResponse_(negotiateMimeType);
                    }
                    else {
                        return this.onNotAcceptableRequest();
                    }
                }
                break;
            case HTTP_RESULT_TYPE.Redirect:
                return this.handleRedirectResult_();
            case HTTP_RESULT_TYPE.File:
                return this.handleFileResult_();
            case HTTP_RESULT_TYPE.FormattedResult:
                return this.handleFormatResult_();
        }
    }
    onResultFromComponent(result) {
        this.controllerResult = result || textResult("");
        // return () => {
        return this.handleFinalResult_;
        // }
    }
}

;// CONCATENATED MODULE: ./src/handlers/request_handler.ts






class RequestHandler extends ControllerResultHandler {
    constructor() {
        super(...arguments);
        this.wallInstances = [];
    }
    registerEvents_() {
        this.request.on('error', (err) => {
            this.onBadRequest(err).catch(ex => {
                this.onErrorOccured(ex);
            });
        });
        this.response.on('error', this.onErrorOccured.bind(this));
    }
    executeWallIncoming_() {
        const wallLength = FORT_GLOBAL.walls.length;
        if (wallLength === 0)
            return;
        return promise((res, rej) => {
            let index = 0;
            const executeWallIncomingByIndex = () => {
                if (wallLength > index) {
                    const wall = FORT_GLOBAL.walls[index++];
                    const constructorArgsValues = InjectorHandler.getConstructorValues(wall.name);
                    const wallObj = new wall(...constructorArgsValues);
                    wallObj['componentProp_'] = this.componentProps;
                    this.wallInstances.push(wallObj);
                    const methodArgsValues = InjectorHandler.getMethodValues(wall.name, 'onIncoming', wallObj);
                    wallObj.onIncoming(...methodArgsValues).then(result => {
                        result == null ? executeWallIncomingByIndex() : res(result);
                    }).catch(rej);
                }
                else {
                    res(null);
                }
            };
            executeWallIncomingByIndex();
        });
    }
    async runController_() {
        const result = await this.setControllerProps_();
        return this.onResultFromComponent(result);
    }
    executeShieldsProtection_() {
        const shields = this.routeMatchInfo_.shields;
        const shieldLength = shields.length;
        if (shieldLength === 0)
            return;
        return promise((res, rej) => {
            let index = 0;
            const executeShieldByIndex = () => {
                if (shieldLength > index) {
                    const shield = shields[index++];
                    const constructorArgsValues = InjectorHandler.getConstructorValues(shield.name);
                    const shieldObj = new shield(...constructorArgsValues);
                    shieldObj['componentProp_'] = this.componentProps;
                    const methodArgsValues = InjectorHandler.getMethodValues(shield.name, 'protect', shieldObj);
                    return shieldObj.protect(...methodArgsValues).then(result => {
                        result == null ? executeShieldByIndex() : res(this.onResultFromComponent(result));
                    }).catch(rej);
                }
                else {
                    res(null);
                }
            };
            executeShieldByIndex();
        });
    }
    executeGuardsCheck_(guards) {
        const guardLength = guards.length;
        if (guardLength === 0)
            return;
        return promise((res, rej) => {
            let index = 0;
            const executeGuardByIndex = () => {
                if (guardLength > index) {
                    const guard = guards[index++];
                    const constructorArgsValues = InjectorHandler.getConstructorValues(guard.name);
                    const guardObj = new guard(...constructorArgsValues);
                    guardObj['componentProp_'] = this.componentProps;
                    const methodArgsValues = InjectorHandler.getMethodValues(guard.name, 'check', guardObj);
                    guardObj.check(...methodArgsValues).then(result => {
                        result == null ? executeGuardByIndex() : res(this.onResultFromComponent(result));
                    }).catch(rej);
                }
                else {
                    res(null);
                }
            };
            executeGuardByIndex();
        });
    }
    setPreHeader_() {
        const response = this.response;
        response.setHeader('X-Powered-By', FORT_GLOBAL.appName);
        response.setHeader('Vary', 'Accept-Encoding');
        response.sendDate = true;
    }
    async onRouteMatched_() {
        const routeMatchInfo = this.routeMatchInfo_;
        const workerInfo = routeMatchInfo.workerInfo;
        this.componentProps.param = routeMatchInfo.params;
        this.componentProps.controllerName = routeMatchInfo.controllerName;
        if (workerInfo == null) {
            return () => {
                return this.request.method === HTTP_METHOD.Options ?
                    this.onRequestOptions(routeMatchInfo.allowedHttpMethod) :
                    this.onMethodNotAllowed(routeMatchInfo.allowedHttpMethod);
            };
        }
        else {
            this.componentProps.workerName = workerInfo.workerName;
            const shieldResult = await this.executeShieldsProtection_();
            if (shieldResult)
                return shieldResult;
            const guardResult = await this.executeGuardsCheck_(workerInfo.guards);
            if (guardResult)
                return guardResult;
            return this.runController_();
        }
    }
    runWallOutgoing_() {
        // check if only Cookie wall has been injected
        if (this.wallInstances.length === 0) {
            return;
        }
        const outgoingResults = [];
        reverseLoop(this.wallInstances, (wallInstance) => {
            const methodArgsValues = InjectorHandler.getMethodValues(wallInstance.constructor.name, 'onOutgoing', wallInstance);
            methodArgsValues.shift();
            outgoingResults.push(wallInstance.onOutgoing(this.controllerResult, ...methodArgsValues));
        });
        return Promise.all(outgoingResults);
    }
    async execute_() {
        const request = this.componentProps.request;
        const urlDetail = external_url_namespaceObject.parse(request.url, true);
        this.componentProps.query = urlDetail.query;
        try {
            const wallResult = await this.executeWallIncoming_();
            if (wallResult) {
                await this.onTerminationFromWall(wallResult);
                return;
            }
            const pathUrl = urlDetail.pathname;
            this.routeMatchInfo_ = parseAndMatchRoute(pathUrl, request.method);
            const finalCallback = await (this.routeMatchInfo_ == null ? () => {
                return this.handleFileRequest(pathUrl);
            } :
                this.onRouteMatched_());
            await this.runWallOutgoing_();
            // using call to pass context, as methods are being returned mostly
            await finalCallback.call(this);
        }
        catch (ex) {
            this.onErrorOccured(ex);
        }
    }
    handle(request, response) {
        this.componentProps = {
            request,
            response,
            data: {},
            global: FORT_GLOBAL
        };
        this.registerEvents_();
        this.setPreHeader_();
        this.execute_();
    }
    setControllerProps_() {
        const controller = this.routeMatchInfo_.controller;
        const controllerName = controller.name;
        const constructorValues = InjectorHandler.getConstructorValues(controllerName);
        const controllerObj = new controller(...constructorValues);
        controllerObj['componentProp_'] = this.componentProps;
        const workerName = this.routeMatchInfo_.workerInfo.workerName;
        const methodArgsValues = InjectorHandler.getMethodValues(controllerName, workerName, controllerObj);
        return controllerObj[workerName](...methodArgsValues);
    }
}

;// CONCATENATED MODULE: ./src/handlers/index.ts







;// CONCATENATED MODULE: ./src/constants/fort_global.ts







const isDevelopment = process.env.NODE_ENV === 'development';
const isProduction = process.env.NODE_ENV === "production";
class FortGlobal {
    constructor() {
        this.port = 4000;
        this.shouldParseCookie = true;
        this.shouldParseBody = true;
        this.sessionTimeOut = 60;
        this.walls = [];
        this.keepAliveTimeout = 30000;
        this.shields = [];
        this.guards = [];
        this.folders = [];
        this.componentOption = new ComponentOption();
    }
    addGuards(guards) {
        this.guards = guards;
    }
    addShields(shields) {
        this.shields = shields;
    }
    get isDevelopment() {
        return isDevelopment;
    }
    get isProduction() {
        return isProduction;
    }
    setDefault() {
        this.viewPath = this.viewPath || CURRENT_PATH;
        this.logger = this.logger || new Logger();
        this.sessionStore = this.sessionStore || MemorySessionStore;
        this.xmlParser = this.xmlParser || BlankXmlParser;
        this.viewEngine = this.viewEngine || new MustacheViewEngine();
        this.appName = this.appName || APP_NAME;
        if (this.eTag == null) {
            this.eTag = {
                type: ETAG_TYPE.Weak
            };
        }
        this.errorHandler = this.errorHandler || ErrorHandler;
        this.validator = this.validator || new DtoValidator();
        this.appSessionIdentifier = `${this.appName}_session_id`;
        if (this.shouldParseCookie === true) {
            this.walls.unshift(CookieEvaluatorWall);
        }
        if (this.shouldParseBody === true) {
            this.guards.unshift(PostDataEvaluatorGuard);
        }
        // add global shields
        RouteHandler.routerCollection.forEach((route) => {
            route.shields = this.shields.concat(route.shields);
            route.workers.forEach((worker) => {
                worker.guards = this.guards.concat(worker.guards);
            });
        });
    }
}
const FORT_GLOBAL = new FortGlobal();

;// CONCATENATED MODULE: ./src/helpers/log_helper.ts

class LogHelper {
    constructor(type, info) {
        this.type = type;
        this.info_ = info;
        this.message = this.getMsg_();
    }
    throw() {
        const errMsg = this.get();
        throw JSON.stringify(errMsg);
    }
    static log(msg) {
        console.log(msg);
    }
    logError() {
        console.error(this.get());
    }
    logWarning() {
        console.warn(this.get());
    }
    get() {
        return {
            message: this.message,
            type: this.type
        };
    }
    getMsg_() {
        let errMsg;
        switch (this.type) {
            case ERROR_TYPE.InvalidControllerName:
                errMsg = `Invalid controller name - '${this.info_}'. Controller name must contain 'controller'.`;
                break;
            case ERROR_TYPE.InvalidContentType:
                errMsg = `Content type - '${this.info_}' is not valid. Please create an issue if you think this is valid type.`;
                break;
            case ERROR_TYPE.PortInUse:
                errMsg = `Port ${this.info_} is being used by another process.`;
                break;
            case ERROR_TYPE.UndefinedViewEngine:
                errMsg = `View engine is not initiated.Initiate the view engine where fort is created.`;
                break;
            default:
                errMsg = this.message;
                break;
        }
        return errMsg;
    }
}

;// CONCATENATED MODULE: ./src/helpers/render_view.ts



let renderView;
if (FORT_GLOBAL.isProduction === true) {
    renderView = (viewName, model) => {
        return FORT_GLOBAL.viewEngine.render({
            view: viewName,
            model
        });
    };
}
else {
    renderView = (viewName, model) => {
        if (FORT_GLOBAL.viewEngine == null) {
            new LogHelper(ERROR_TYPE.UndefinedViewEngine).throw();
        }
        return FORT_GLOBAL.viewEngine.render({
            view: viewName,
            model
        });
    };
}

;// CONCATENATED MODULE: ./src/helpers/download_result.ts


const downloadResult = (filePath, downloadFileName) => {
    return {
        statusCode: HTTP_STATUS_CODE.Ok,
        responseData: {
            filePath: filePath,
            shouldDownload: true,
            alias: downloadFileName
        },
        type: HTTP_RESULT_TYPE.File
    };
};

;// CONCATENATED MODULE: ./src/helpers/file_result.ts

const fileResult = (filePath) => {
    return {
        statusCode: HTTP_STATUS_CODE.Ok,
        responseData: {
            filePath: filePath
        },
        type: HTTP_RESULT_TYPE.File
    };
};

;// CONCATENATED MODULE: ./src/helpers/redirect_result.ts


const redirectResult = (url) => {
    return {
        contentType: MIME_TYPE.Text,
        responseData: url,
        statusCode: HTTP_STATUS_CODE.Redirect,
        type: HTTP_RESULT_TYPE.Redirect
    };
};

;// CONCATENATED MODULE: ./src/helpers/view_result.ts


const viewResult = (viewName, model) => {
    return renderView(viewName, model).then(viewData => {
        return {
            contentType: MIME_TYPE.Html,
            responseData: viewData,
            statusCode: HTTP_STATUS_CODE.Ok,
            type: HTTP_RESULT_TYPE.Default
        };
    });
};

;// CONCATENATED MODULE: external "fs-extra"
const external_fs_extra_namespaceObject = require("fs-extra");
;// CONCATENATED MODULE: ./src/helpers/get_view_from_file.ts




const viewCache = {};
let getViewFromFile;
const readView = (option) => {
    const pathOfView = external_path_namespaceObject.join(FORT_GLOBAL.viewPath, option.fileLocation);
    // eslint-disable-next-line
    return (0,external_fs_extra_namespaceObject.readFile)(pathOfView, {
        encoding: 'utf8'
    }).then(result => {
        if (option.mapView != null) {
            return option.mapView(result);
        }
        return result;
    });
};
if (FORT_GLOBAL.isProduction === true) {
    getViewFromFile = function (option) {
        if (viewCache[option.fileLocation] == null) {
            return readView(option).then(result => {
                viewCache[option.fileLocation] = result;
                return result;
            });
        }
        return promiseResolve(viewCache[option.fileLocation]);
    };
}
else {
    getViewFromFile = function (option) {
        return readView(option);
    };
}

;// CONCATENATED MODULE: ./src/helpers/promise.ts
const promise = (callBack) => {
    return new Promise(callBack);
};

;// CONCATENATED MODULE: ./src/helpers/get_mime_type_from_extension.ts

const getMimeTypeFromExtension = (ext) => {
    switch (ext) {
        case ".htm":
        case ".html":
            return MIME_TYPE.Html;
        case ".css":
            return MIME_TYPE.Css;
        case ".js":
            return MIME_TYPE.Js;
        case ".png":
            return MIME_TYPE.Png;
        case ".woff":
            return MIME_TYPE.Woff;
        case ".woff2":
            return MIME_TYPE.Woff2;
        case ".json":
            return MIME_TYPE.Json;
        case ".txt":
            return MIME_TYPE.Text;
        case ".jpg":
        case ".jpeg":
            return MIME_TYPE.Jpeg;
        case ".rtf":
            return MIME_TYPE.Rtf;
        case ".ttf":
            return MIME_TYPE.Ttf;
        case ".eot":
            return MIME_TYPE.Eot;
        case '.otf':
            return MIME_TYPE.Otf;
        case ".swf":
            return MIME_TYPE.Swf;
        case ".avi":
            return MIME_TYPE.Avi;
        case ".svg":
            return MIME_TYPE.Svg;
        case ".pdf":
            return MIME_TYPE.Pdf;
        case ".xml":
            return MIME_TYPE.Xml;
        case ".csv":
            return MIME_TYPE.Csv;
        case ".xls":
            return MIME_TYPE.Xls;
        case ".xlsx":
            return MIME_TYPE.Xlsx;
        case ".bmp":
            return MIME_TYPE.Bmp;
        case ".gif":
            return MIME_TYPE.Gif;
        default:
            return "application/octet-stream";
    }
};

;// CONCATENATED MODULE: ./src/helpers/remove_last_slash.ts
const removeLastSlash = (url) => {
    const urlLength = url.length;
    // removing / from url;
    if (url[urlLength - 1] === "/") {
        return url.substring(0, urlLength - 1);
    }
    return url;
};

;// CONCATENATED MODULE: ./src/helpers/parse_match_route.ts



const regex1 = /{(.*)}(?!.)/;
// for extension - e.g - {{file}}.js
const regex2 = /{(.*)}\.(\w+)(?!.)/;
const checkRouteInWorker = (route, httpMethod, urlParts) => {
    const matchedRoute = {
        allowedHttpMethod: [],
        controller: route.controller,
        controllerName: route.controllerName
    };
    const urlPartLength = urlParts.length;
    for (const worker of route.workers.values()) {
        const patternSplit = worker.patternSplitted;
        if (urlPartLength !== patternSplit.length)
            continue;
        let isMatched = true;
        const params = {};
        urlParts.every((urlPart, i) => {
            const patternSplitAtIndex = patternSplit[i];
            // if not equal then check for regex match
            if (compareString(urlPart, patternSplitAtIndex) === false) {
                const regMatch1 = patternSplitAtIndex.match(regex1);
                if (regMatch1 != null) {
                    params[regMatch1[1]] = urlPart;
                    return true;
                }
                const regMatch2 = patternSplitAtIndex.match(regex2);
                if (regMatch2 != null) {
                    const splitByDot = urlPart.split(".");
                    if (splitByDot[1] === regMatch2[2]) {
                        params[regMatch2[1]] = splitByDot[0];
                        return true;
                    }
                }
                isMatched = false;
            }
            // means its direct match
            return isMatched;
        });
        if (isMatched === true) {
            if (!worker.methodsAllowed) {
                throw `Invalid route registration in Controller : ${route.controllerName} and method : ${worker.workerName}.Route exist but method has not been decorated with worker.`;
            }
            if (worker.methodsAllowed.indexOf(httpMethod) >= 0) {
                matchedRoute.workerInfo = worker;
                matchedRoute.params = params;
                matchedRoute.shields = route.shields;
                return matchedRoute;
            }
            else {
                matchedRoute.allowedHttpMethod = [...matchedRoute.allowedHttpMethod, ...worker.methodsAllowed];
            }
        }
    }
    if (matchedRoute.allowedHttpMethod.length === 0) {
        return null;
    }
    matchedRoute.params = {};
    return matchedRoute;
};
function parseAndMatchRoute(url, httpMethod) {
    url = removeLastSlash(url);
    const urlAndMethod = url + httpMethod;
    const cache = RouteHandler.getRouteFromCache(urlAndMethod);
    if (cache) {
        return cache;
    }
    const urlParts = url.split("/");
    const route = RouteHandler.findControllerFromPath(urlParts);
    const result = route == null ? checkRouteInWorker(RouteHandler.defaultRoute, httpMethod, urlParts) :
        checkRouteInWorker(route, httpMethod, urlParts);
    // do not cache route which have params
    if (result && Object.keys(result.params).length === 0) {
        RouteHandler.addRouteToCache(urlAndMethod, result);
    }
    return result;
}

;// CONCATENATED MODULE: ./src/helpers/parse_cookie.ts

const parseCookie = (cookie) => {
    const value = {};
    if (!isNullOrEmpty(cookie)) {
        cookie.split(';').forEach((val) => {
            const parts = val.split('=');
            value[parts.shift().trim()] = decodeURI(parts.join('='));
        });
    }
    return value;
};

;// CONCATENATED MODULE: ./src/helpers/json_helper.ts
class JsonHelper {
    static parse(value) {
        try {
            return JSON.parse(value);
        }
        catch (ex) {
            // tslint:disable-next-line
            throw {
                message: "Post data is invalid"
            };
        }
    }
    static stringify(value) {
        return JSON.stringify(value);
    }
}

;// CONCATENATED MODULE: ./src/helpers/remove_first_slash.ts
const removeFirstSlash = function (value) {
    // remove / from string at 0th index
    if (value[0] === "/") {
        return value.substring(1);
    }
    return value;
};

;// CONCATENATED MODULE: ./src/helpers/reverse_loop.ts
const reverseLoop = function (values, cb) {
    for (let length = values.length, i = length - 1; i >= 0; i--) {
        cb(values[i], i);
    }
};

;// CONCATENATED MODULE: ./src/helpers/get_data_type.ts

const getDataType = (value) => {
    const type = typeof value;
    switch (type) {
        case 'object':
            if (Array.isArray(value)) {
                return DATA_TYPE.Array;
            }
        default:
            return type;
    }
};

;// CONCATENATED MODULE: ./src/helpers/get_class_name.ts
const getClassName = (target) => {
    return target.name || (target.constructor && target.constructor.name);
};

;// CONCATENATED MODULE: ./src/helpers/remove_method_and_null_from_object.ts


const removeMethodAndNullFromObject = (value) => {
    const outputValue = {};
    for (const prop in value) {
        const type = getDataType(value[prop]);
        if (!(value[prop] == null || type === DATA_TYPE.Function)) {
            outputValue[prop] = value[prop];
        }
    }
    return outputValue;
};

;// CONCATENATED MODULE: ./src/helpers/get_result_based_on_mime.ts

let getResultBasedOnMiMe = (type, result, setMimeType) => {
    switch (type) {
        case MIME_TYPE.Json:
        case MIME_TYPE.Text:
        case MIME_TYPE.Html:
        case MIME_TYPE.Xml:
            if (typeof result === 'object' === true) {
                setMimeType(MIME_TYPE.Json);
                return JSON.stringify(result);
            }
    }
    return result;
};
function setResultMapper(mapper) {
    getResultBasedOnMiMe = (type, result, callBack) => {
        return new mapper().map(type, result, callBack);
    };
}

;// CONCATENATED MODULE: ./src/helpers/get_mime_type_from_file_type.ts

function getMimeTypeFromFileType(fileType) {
    return fileType[0] === '.' ? getMimeTypeFromExtension(fileType) :
        fileType;
}

;// CONCATENATED MODULE: ./src/helpers/split_route.ts
const splitRoute = (value) => {
    return value.split("/");
};
const joinRoute = (value) => {
    return value.join("/");
};

;// CONCATENATED MODULE: ./src/helpers/execute_validate.ts

const executeValidate = async (dtoClass, data) => {
    const validator = FORT_GLOBAL.validator;
    const dtoInstance = new dtoClass(data);
    if (Object.keys(dtoInstance).length === 0) {
        Object.assign(dtoInstance, data);
    }
    const validationResult = await validator.validate(dtoInstance);
    if (validationResult) {
        return {
            error: validator.getErrorResult(validationResult)
        };
    }
    return {
        model: dtoInstance
    };
};

;// CONCATENATED MODULE: ./src/helpers/validate_param_guard.ts



class ValidateParamGuard extends Guard {
    async check() {
        const componentProp = this['componentProp_'];
        const expectedValue = RouteHandler.getExpectedParam(componentProp.controllerName, this.workerName);
        if (expectedValue == null)
            return;
        const validationResult = await executeValidate(expectedValue, this.param);
        if (validationResult.error) {
            return validationResult.error;
        }
        componentProp.param = validationResult.model;
    }
}

;// CONCATENATED MODULE: ./src/helpers/validate_body_guard.ts



class ValidateBodyGuard extends Guard {
    async check() {
        const componentProp = this['componentProp_'];
        const expectedBody = RouteHandler.getExpectedBody(componentProp.controllerName, this.workerName);
        if (expectedBody == null)
            return;
        const validationResult = await executeValidate(expectedBody, this.body);
        if (validationResult.error) {
            return validationResult.error;
        }
        componentProp.body = validationResult.model;
    }
}

;// CONCATENATED MODULE: ./src/helpers/validate_query_shield.ts



class ValidateQueryShield extends Shield {
    async protect() {
        const componentProp = this['componentProp_'];
        const expectedQuery = RouteHandler.getExpectedQuery(componentProp.controllerName, this.workerName);
        if (expectedQuery == null)
            return;
        const validationResult = await executeValidate(expectedQuery, this.query);
        if (validationResult.error) {
            return validationResult.error;
        }
        componentProp.query = validationResult.model;
    }
}

;// CONCATENATED MODULE: ./src/helpers/multi_format_result.ts


const multiTypeResult = (value, statusCode) => {
    return {
        responseData: value,
        statusCode: statusCode || HTTP_STATUS_CODE.Ok,
        type: HTTP_RESULT_TYPE.FormattedResult
    };
};

;// CONCATENATED MODULE: ./src/helpers/test/http_response_stub.ts
class HttpResponseStub {
    constructor(headers) {
        this.headers_ = headers;
    }
    getHeader(name) {
        return this.headers_[name];
    }
    hasHeader(name) {
        return this.headers_[name] != null;
    }
    setHeader(name, value) {
        this.headers_[name] = value;
    }
    getHeaders() {
        return this.headers_;
    }
    getHeaderNames() {
        return Object.keys[this.headers_];
    }
    removeHeader(name) {
        delete this.headers_[name];
    }
}

;// CONCATENATED MODULE: ./src/helpers/test/http_request_stub.ts
class HttpRequestStub {
    constructor(headers) {
        this.headers = headers;
    }
}

;// CONCATENATED MODULE: ./src/helpers/test/init_controller.ts





const initController = (controllerInstance, data) => {
    data = data || {};
    const parsedCookies = data.cookieValue || {};
    const headers = (data.request && data.request.headers) || {};
    const cookie = new CookieManager(parsedCookies);
    const session = new SessionManager(cookie, FORT_GLOBAL.sessionStore);
    controllerInstance['componentProp_'] = {
        request: new HttpRequestStub(headers),
        response: new HttpResponseStub(headers),
        query: data.query || {},
        body: data.body || {},
        cookie: cookie,
        session: session,
        param: data.param || {},
        data: data.data || {},
        file: new FileManager(data.file || {}),
        workerName: data.workerName,
        global: FORT_GLOBAL
    };
    return controllerInstance;
};

;// CONCATENATED MODULE: ./src/helpers/test/init_guard.ts

const initGuard = (guardInstance, data) => {
    return initController(guardInstance, data);
};

;// CONCATENATED MODULE: ./src/helpers/test/init_shield.ts

const initShield = (shieldInstance, data) => {
    const value = initController(shieldInstance, data);
    return value;
};

;// CONCATENATED MODULE: ./src/helpers/test/init_wall.ts

const initWall = (wallInstance, data) => {
    return initController(wallInstance, data);
};

;// CONCATENATED MODULE: ./src/helpers/test/index.ts





;// CONCATENATED MODULE: ./src/helpers/index.ts






























;// CONCATENATED MODULE: ./src/models/error_handler.ts



class ErrorHandler {
    onServerError(ex) {
        let errMessage = `<h1>internal server error</h1>
            <h3>message : ${ex.message}</h3>`;
        if (ex.stack) {
            errMessage += `<p><b>stacktrace:</b> ${ex.stack}</p>`;
        }
        if (ex.type) {
            errMessage += `<p><b>type:</b> ${ex.type}</p>`;
        }
        return promiseResolve(htmlResult(errMessage, HTTP_STATUS_CODE.InternalServerError));
    }
    onBadRequest(ex) {
        let errMessage = `<h1>Bad Request</h1>`;
        if (ex.message) {
            errMessage += ` <h3>message : ${ex.message} </h3>`;
        }
        if (ex.stack) {
            errMessage += `<p><b>stacktrace:</b> ${ex.stack}</p>`;
        }
        if (ex.type) {
            errMessage += `<p><b>type:</b> ${ex.type}</p>`;
        }
        return promiseResolve(htmlResult(errMessage, HTTP_STATUS_CODE.BadRequest));
    }
    onForbiddenRequest() {
        return promiseResolve(htmlResult(`<h1>Forbidden</h1>`, HTTP_STATUS_CODE.Forbidden));
    }
    onNotAcceptableRequest() {
        return promiseResolve(htmlResult(`<h1>Not Acceptable</h1>`, HTTP_STATUS_CODE.NotAcceptable));
    }
    onMethodNotAllowed() {
        return promiseResolve(htmlResult(`<h1>Method Not allowed.</h1>`, HTTP_STATUS_CODE.MethodNotAllowed));
    }
    onNotFound(url) {
        return promiseResolve(htmlResult(`<h1>The requested resource ${url} was not found.</h1>`, HTTP_STATUS_CODE.NotFound));
    }
}

;// CONCATENATED MODULE: ./src/models/http_cookie.ts
class HttpCookie {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
}

;// CONCATENATED MODULE: external "http"
const external_http_namespaceObject = require("http");
;// CONCATENATED MODULE: ./src/models/fort.ts







class Fort {
    static set logger(value) {
        FORT_GLOBAL.logger = typeof value === 'function' ? new this.value() :
            value;
    }
    static get logger() {
        return FORT_GLOBAL.logger;
    }
    static set walls(walls) {
        FORT_GLOBAL.walls = walls;
    }
    static get walls() {
        return FORT_GLOBAL.walls;
    }
    static set shields(shields) {
        FORT_GLOBAL.addShields(shields);
    }
    static set guards(guards) {
        FORT_GLOBAL.addGuards(guards);
    }
    /**
     * port at which app will listen, default - 4000
     *
     * @static
     * @memberof Fort
     */
    static set port(value) {
        FORT_GLOBAL.port = value;
    }
    static get port() {
        return FORT_GLOBAL.port;
    }
    /**
     * typeof ErrorHandler
     *
     * @static
     * @memberof Fort
     */
    static set errorHandler(value) {
        FORT_GLOBAL.errorHandler = value;
    }
    static set routes(value) {
        if (value == null) {
            value = [];
        }
        let isDefaultRouteExist = false;
        // removing / from routes
        value.forEach(route => {
            // route.path = removeFirstSlash(route.path);
            route.path = removeLastSlash(route.path);
            RouteHandler.addToRouterCollection(route);
            if (route.path === "/*") {
                RouteHandler.defaultRouteControllerName = route.controller.name;
                isDefaultRouteExist = true;
            }
        });
        if (isDefaultRouteExist === false) {
            class GenericController extends Controller {
            }
            RouteHandler.defaultRouteControllerName = GenericController.name;
            RouteHandler.addToRouterCollection({
                controller: GenericController,
                path: "/*"
            });
        }
    }
    /**
     * view engine use to render the view
     *
     * @static
     * @memberof Fort
     */
    static set viewEngine(value) {
        FORT_GLOBAL.viewEngine = new value();
    }
    /**
     * sessionStore class, default - MemorySessionStore
     *
     * @static
     * @memberof Fort
     */
    static set sessionStore(value) {
        FORT_GLOBAL.sessionStore = value;
    }
    static set resultMapper(value) {
        setResultMapper(value);
    }
    /**
     * XmlParser class - used to parse the xml
     *
     * @static
     * @memberof Fort
     */
    static set xmlParser(xmlParser) {
        FORT_GLOBAL.xmlParser = xmlParser;
    }
    /**
     * Whether to parse cookie or not, default - true
     * If false, then session wont work.
     *
     * @static
     * @memberof Fort
     */
    static set shouldParseCookie(value) {
        FORT_GLOBAL.shouldParseCookie = value;
    }
    /**
     * Whether to parse the http body data in post request, default - true
     *
     * @static
     * @memberof Fort
     */
    static set shouldParseBody(value) {
        FORT_GLOBAL.shouldParseBody = value;
    }
    /**
     * session timeout in minute - default is 60 minute
     *
     * @static
     * @memberof Fort
     */
    static set sessionTimeOut(value) {
        FORT_GLOBAL.sessionTimeOut = value;
    }
    /**
     * name of application - default is fort. Visible in header and cookie.
     * Change name if you dont want any one to know the framework name.
     *
     * @static
     * @memberof Fort
     */
    static set appName(value) {
        FORT_GLOBAL.appName = value;
    }
    /**
     * Views folder location. By default it is - views.
     *
     * @static
     * @memberof Fort
     */
    static set viewPath(value) {
        FORT_GLOBAL.viewPath = value;
    }
    static set componentOption(value) {
        FORT_GLOBAL.componentOption = new value();
    }
    static get httpServer() {
        return Fort.instance.httpServer;
    }
    static set httpServer(value) {
        Fort.instance.httpServer = value;
    }
    /**
     * folders which should be visible to requests. By default nothing is allowed.
     *
     * @static
     * @memberof Fort
     */
    static set folders(value) {
        value = value || [];
        if (isArray(value) === false) {
            throw new Error(`folders should be an array`);
        }
        // remove / from files routes
        value.forEach(folder => {
            const length = folder.alias.length;
            if (length > 1) {
                folder.alias = removeFirstSlash(folder.alias);
                folder.alias = removeLastSlash(folder.alias);
            }
        });
        FORT_GLOBAL.folders = value;
    }
    /**
     * eTag Settings
     *
     * @static
     * @memberof Fort
     */
    static set eTag(value) {
        FORT_GLOBAL.eTag = value;
    }
    /**
     * keep alive timeout in millisecond for requests, default is 72000
     *
     * @static
     * @memberof Fort
     */
    static set keepAliveTimeout(value) {
        FORT_GLOBAL.keepAliveTimeout = value;
    }
    // eslint-disable-next-line
    constructor() {
    }
    static create() {
        FORT_GLOBAL.setDefault();
        if (this.instance.httpServer != null) {
            return;
        }
        return promise((res, rej) => {
            this.instance.httpServer = external_http_namespaceObject.createServer(Fort.onNewRequest).once("error", (err) => {
                if (err.code === 'EADDRINUSE') {
                    const error = new LogHelper(ERROR_TYPE.PortInUse, FORT_GLOBAL.port).get();
                    rej(error);
                }
                else {
                    rej(err);
                }
            }).once('listening', () => {
                res();
            }).listen(FORT_GLOBAL.port);
            this.instance.httpServer.keepAliveTimeout = FORT_GLOBAL.keepAliveTimeout;
        });
    }
    static onNewRequest(request, response) {
        new RequestHandler().handle(request, response);
    }
    static destroy() {
        return promise((res) => {
            this.instance.httpServer.close(res);
        });
    }
    static set validator(validator) {
        FORT_GLOBAL.validator = validator;
    }
}
Fort.instance = new Fort();

;// CONCATENATED MODULE: ./src/models/router.ts

class Router {
    get routes() {
        return RouteHandler.routerCollection;
    }
    get routesAsArray() {
        return RouteHandler.routesAsArray;
    }
}

;// CONCATENATED MODULE: ./src/models/cookie_manager.ts
class CookieManager {
    constructor(parsedValue) {
        this.responseCookie_ = [];
        this.cookieCollection_ = parsedValue;
    }
    /**
     * return cookie by name
     *
     * @param {string} name
     * @returns
     * @memberof CookieManager
     */
    getCookie(name) {
        return {
            name: name,
            value: this.cookieCollection_[name]
        };
    }
    /**
     * add cookie
     *
     * @param {HttpCookie} cookie
     * @memberof CookieManager
     */
    addCookie(cookie) {
        this.cookieCollection_[cookie.name] = cookie.value;
        this.responseCookie_.push(this.getCookieStringFromCookie_(cookie));
    }
    /**
     * remove cookie
     *
     * @param {HttpCookie} cookie
     * @memberof CookieManager
     */
    removeCookie(cookie) {
        this.cookieCollection_[cookie.name] = null;
        cookie.expires = new Date('Thu, 01 Jan 1970 00:00:00 GMT');
        cookie.maxAge = -1;
        this.responseCookie_.push(this.getCookieStringFromCookie_(cookie));
    }
    /**
     * collection of http cookie
     *
     * @readonly
     * @memberof CookieManager
     */
    get cookieCollection() {
        return this.cookieCollection_;
    }
    /**
     * determine whether value exist or not
     *
     * @param {string} name
     * @returns
     * @memberof CookieManager
     */
    isExist(name) {
        return this.cookieCollection_[name] != null;
    }
    getCookieStringFromCookie_(cookie) {
        const cookies = [];
        cookies.push(`${cookie.name}=${cookie.value}`);
        if (cookie.expires) {
            cookies.push(`Expires=${cookie.expires.toUTCString()}`);
        }
        if (cookie.httpOnly === true) {
            cookies.push("HttpOnly");
        }
        if (cookie.maxAge != null) {
            cookies.push(`Max-Age=${cookie.maxAge}`);
        }
        if (cookie.path) {
            cookies.push(`Path=${cookie.path}`);
        }
        if (cookie.domain) {
            cookies.push(`Domain=${cookie.domain}`);
        }
        return cookies.join('; ');
    }
}

;// CONCATENATED MODULE: ./src/models/file_manager.ts

class FileManager {
    constructor(value) {
        this.files_ = value;
    }
    /**
     * get total no of files
     *
     * @returns - number
     * @memberof FileManager
     */
    get count() {
        return Object.keys(this.files_).length;
    }
    get files() {
        return Object.keys(this.files_).map(fileId => {
            return this.files_[fileId];
        });
    }
    /**
     * check for existance of file
     *
     * @param {string} fieldName
     * @returns
     * @memberof FileManager
     */
    isExist(fieldName) {
        return this.files_[fieldName] != null;
    }
    /**
     * return the file
     *
     * @param {string} fieldName
     * @returns
     * @memberof FileManager
     */
    getFile(fieldName) {
        return this.files_[fieldName];
    }
    /**
     * saves file to supplied path
     *
     * @param {string} fieldName
     * @param {string} pathToSave
     * @returns
     * @memberof FileManager
     */
    saveTo(fieldName, pathToSave) {
        return external_fs_extra_namespaceObject.copy(this.files_[fieldName].path, pathToSave);
    }
}

;// CONCATENATED MODULE: ./src/models/http_file.ts
class HttpFile {
}

;// CONCATENATED MODULE: ./src/models/logger.ts
class Logger {
    info(...args) {
        this.debug(args);
    }
    error(...args) {
        this.debug(args);
    }
    log(...args) {
        this.debug(args);
    }
    debug(...args) {
        console.log(...args);
    }
}

;// CONCATENATED MODULE: ./src/models/route_info.ts
class RouteInfo {
    get workersAsArray() {
        return Array.from(this.workers.keys()).map(workerName => {
            return this.workers.get(workerName);
        });
    }
    constructor(value) {
        this.controllerName = value.controllerName;
        this.controller = value.controller;
        this.path = value.path;
        this.shields = value.shields;
        this.values = value.values;
        this.workers = value.workers;
    }
    set path(value) {
        if (value) {
            this.pathSplitted = value.split("/");
        }
    }
}

;// CONCATENATED MODULE: ./src/models/components.ts

class ControllerListRef {
    static getInstance(name, data) {
        const routeInfo = RouteHandler.getControllerFromName(name);
        if (routeInfo) {
            const controller = new routeInfo.controller(...InjectorHandler.getConstructorValues(name));
            if (data) {
                controller.initialize(data);
            }
            return controller;
        }
    }
    static getMethod(className, methodName) {
        const controller = ControllerListRef.getInstance(className);
        if (controller) {
            return controller[methodName];
        }
    }
    static executeMethod(className, methodName) {
        const controller = ControllerListRef.getInstance(className);
        if (controller) {
            return controller[methodName](...InjectorHandler.getMethodValues(className, methodName, null));
        }
    }
}
class Components {
}
Components.controller = ControllerListRef;

;// CONCATENATED MODULE: ./src/models/worker_info.ts

class WorkerInfo {
    constructor(value) {
        this.workerName = value.workerName;
        this.methodsAllowed = value.methodsAllowed;
        this.guards = value.guards;
        this.values = value.values;
        this.expectedQuery = value.expectedQuery;
        this.expectedBody = value.expectedBody;
        this.pattern = value.pattern;
    }
    set pattern(value) {
        this.patternSplitted = splitRoute(value || "");
    }
    get pattern() {
        return joinRoute(this.patternSplitted);
    }
}

;// CONCATENATED MODULE: ./src/models/index.ts












;// CONCATENATED MODULE: ./src/decorators/wrap_method_decorator.ts
function wrapMethodDecorator(args, executor) {
    // this is executed without param
    if (args.length > 2 && args[2].writable != null) {
        const [target, propertyName] = args;
        executor(target, propertyName);
        return;
    }
    return (target, key) => {
        executor(target, key, ...args);
    };
}

;// CONCATENATED MODULE: ./src/decorators/worker.ts



function worker(...args) {
    return wrapMethodDecorator(args, createWorker);
}
const allHttpMethod = [
    HTTP_METHOD.Delete,
    HTTP_METHOD.Get,
    HTTP_METHOD.Post,
    HTTP_METHOD.Patch,
    HTTP_METHOD.Put
];
function createWorker(target, methodName, ...allowedMethods) {
    const className = target.constructor.name;
    const actionInfo = {
        workerName: methodName,
        methodsAllowed: allowedMethods.length === 0 ? allHttpMethod : allowedMethods,
        guards: [],
        pattern: `/${methodName.toLowerCase()}`,
        values: []
    };
    RouteHandler.addWorker(actionInfo, className);
}

;// CONCATENATED MODULE: ./src/decorators/shields.ts

const shields = (...shields) => {
    return (target) => {
        const className = target.name;
        RouteHandler.addShields(shields, className);
    };
};

;// CONCATENATED MODULE: ./src/decorators/guards.ts

const guards = (...value) => {
    return ((target, methodName) => {
        const className = target.constructor.name;
        RouteHandler.addGuards(value, className, methodName);
    });
};

;// CONCATENATED MODULE: ./src/decorators/route.ts


const route = (format) => {
    return ((target, methodName) => {
        const className = target.constructor.name;
        // remove / from route
        if (format != null) {
            format = removeLastSlash(format);
        }
        RouteHandler.addPattern(format, className, methodName);
    });
};

;// CONCATENATED MODULE: ./src/decorators/default_worker.ts




function defaultWorker(...args) {
    return wrapMethodDecorator(args, default_worker_createWorker);
}
function default_worker_createWorker(target, methodName, ...allowedMethods) {
    const args = (allowedMethods.length === 0 ? [HTTP_METHOD.Get] : allowedMethods);
    worker(...args)(target, methodName, null);
    route("/")(target, methodName, null);
}

;// CONCATENATED MODULE: ./src/decorators/assign.ts


const assign_assign = (value) => {
    return (target, methodName, paramIndex) => {
        const className = target.name || target.constructor.name;
        if (methodName == null) {
            methodName = CONSTRUCTOR;
        }
        InjectorHandler.addWorkerValue(className, methodName, paramIndex, value);
    };
};

;// CONCATENATED MODULE: ./src/decorators/singleton.ts


const singleton = (value) => {
    return (target, methodName, paramIndex) => {
        const className = target.name || target.constructor.name;
        if (methodName == null || methodName === 'constructor') {
            methodName = CONSTRUCTOR;
        }
        InjectorHandler.addSingleton(className, methodName, paramIndex, value);
    };
};

;// CONCATENATED MODULE: ./src/decorators/validate.ts


const validate = {
    body: function (value) {
        return (target, methodName) => {
            const className = getClassName(target);
            RouteHandler.addExpected("body", className, methodName, value);
            RouteHandler.addGuards([ValidateBodyGuard], className, methodName);
        };
    },
    param: function (value) {
        return (target, methodName) => {
            const className = getClassName(target);
            RouteHandler.addExpected("param", className, methodName, value);
            RouteHandler.addGuards([ValidateParamGuard], className, methodName);
        };
    },
    query: function (value) {
        return (target, methodName) => {
            const className = getClassName(target);
            RouteHandler.addExpected("query", className, methodName, value);
            RouteHandler.addShields([ValidateQueryShield], className);
        };
    }
};

;// CONCATENATED MODULE: ./src/decorators/body.ts

const createBodyInjectParam = (type, prop) => {
    return {
        "__fortReqType__": type,
        inject: (controller) => {
            return controller[prop];
        }
    };
};
function asBody(target, propertyKey, parameterIndex) {
    assign_assign(createBodyInjectParam("body", "body"))(target, propertyKey, parameterIndex);
}
function asQuery(target, methodName, paramIndex) {
    assign_assign(createBodyInjectParam("query", "query"))(target, methodName, paramIndex);
}
function asParam(target, methodName, paramIndex) {
    assign_assign(createBodyInjectParam("param", "param"))(target, methodName, paramIndex);
}

;// CONCATENATED MODULE: ./src/decorators/req_method.ts




function get(...args) {
    return wrapMethodDecorator(args, createWorkerForGet);
}
function post(...args) {
    return wrapMethodDecorator(args, createWorkerForPost);
}
function del(...args) {
    return wrapMethodDecorator(args, createWorkerForDelete);
}
function patch(...args) {
    return wrapMethodDecorator(args, createWorkerForPatch);
}
function put(...args) {
    return wrapMethodDecorator(args, createWorkerForPut);
}
function registerWorkerAndCreate(target, methodName, httpMethod, routes) {
    const routeArg = (routes.length === 0 ? null : routes[0]);
    worker(httpMethod)(target, methodName, null);
    route(routeArg)(target, methodName, null);
}
function createWorkerForGet(target, methodName, ...routes) {
    registerWorkerAndCreate(target, methodName, HTTP_METHOD.Get, routes);
}
function createWorkerForPost(target, methodName, ...routes) {
    registerWorkerAndCreate(target, methodName, HTTP_METHOD.Post, routes);
}
function createWorkerForPatch(target, methodName, ...routes) {
    registerWorkerAndCreate(target, methodName, HTTP_METHOD.Patch, routes);
}
function createWorkerForPut(target, methodName, ...routes) {
    registerWorkerAndCreate(target, methodName, HTTP_METHOD.Put, routes);
}
function createWorkerForDelete(target, methodName, ...routes) {
    registerWorkerAndCreate(target, methodName, HTTP_METHOD.Delete, routes);
}
const http = {
    get, post, delete: del,
    patch, put
};

;// CONCATENATED MODULE: ./src/decorators/index.ts











;// CONCATENATED MODULE: ./src/index.ts









module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=fort.js.map